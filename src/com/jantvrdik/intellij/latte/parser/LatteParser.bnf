{
	parserClass="com.jantvrdik.intellij.latte.parser.LatteParser"
	parserUtilClass="com.jantvrdik.intellij.latte.parser.LatteParserUtil"

	extends="com.intellij.extapi.psi.ASTWrapperPsiElement"

	psiClassPrefix="Latte"
	psiImplClassSuffix="Impl"
	psiPackage="com.jantvrdik.intellij.latte.psi"
	psiImplPackage="com.jantvrdik.intellij.latte.psi.impl"
	psiImplUtilClass="com.jantvrdik.intellij.latte.psi.impl.LattePsiImplUtil"

	elementTypeHolderClass="com.jantvrdik.intellij.latte.psi.LatteTypes"
	elementTypeClass="com.jantvrdik.intellij.latte.psi.LatteElementType"
	tokenTypeClass="com.jantvrdik.intellij.latte.psi.LatteTokenType"
}

root             ::= (structureToken)* autoClosedBlock?

// macro
private
macro            ::= macroAnnotation | macroComment | latteMacro

latteMacro        ::= macroClassic {
                            mixin="com.jantvrdik.intellij.latte.psi.impl.LatteMacroElementImpl"
                            implements="com.jantvrdik.intellij.latte.psi.LatteMacroElement"
                        }

macroAnnotation  ::= T_ANNOTATION_OPEN_TAG_OPEN T_ANNOTATION_TAG_OPEN T_WHITESPACE? argsVar T_WHITESPACE? (T_ANNOTATION_OPERATOR T_WHITESPACE? argsVarType?)? T_WHITESPACE? T_ANNOTATION_TAG_CLOSE T_ANNOTATION_OPEN_TAG_CLOSE
macroComment     ::= T_MACRO_COMMENT
macroClassic     ::= <<checkPairMacro true>> (pairMacro | emptyMacro) | <<checkPairMacro false>> unpairedMacro {
                     	methods = [
                     		openTag="macroTag[0]"
                     		closeTag="macroTag[1]"
                     	]
                     }

private
pairMacro        ::= macroOpenTag structureToken* macroCloseTag

private
emptyMacro       ::= emptyMacroTag;

private
unpairedMacro    ::= macroOpenTag

fake
macroTag         ::= classicMacroContent {
                     	methods = [
                     		getMacroName
                     		macroContent="macroContent"
                     	]
                     }

macroOpenTag     ::= T_MACRO_OPEN_TAG_OPEN classicMacroContent T_MACRO_TAG_CLOSE {
                     	extends = macroTag
                     }
macroCloseTag    ::= T_MACRO_CLOSE_TAG_OPEN classicMacroContent T_MACRO_TAG_CLOSE {
                     	extends = macroTag
                     }
emptyMacroTag    ::= T_MACRO_OPEN_TAG_OPEN classicMacroContent T_MACRO_TAG_CLOSE_EMPTY {
                     	extends = macroTag
                     }


private
classicMacroContent     ::= ("var " (variableDefinition)) | ("for " forCycle) | ("foreach " foreach) | (macroName (phpContent | macroContent?))

macroContent ::= macroArgs? (T_MACRO_MODIFIERS macroArgs)*

phpContent ::= foreach | phpArgs

private
phpArgs ::= argsVar | argsVarType | T_MACRO_ARGS_STRING | T_MACRO_ARGS_NUMBER | phpMethod | phpOperators

private
phpOperators ::= "=" | "=>" | T_PHP_OPERATOR

private
macroName        ::= T_MACRO_NAME
                   | T_MACRO_NOESCAPE? T_MACRO_SHORTNAME?

private
macroArgs        ::= macroArg+

private
macroArg        ::= T_MACRO_ARGS | phpArgs

argsVar        ::= T_MACRO_ARGS_VAR phpSubMethod* {
                        mixin="com.jantvrdik.intellij.latte.psi.impl.LatteVariableElementImpl"
                        implements="com.jantvrdik.intellij.latte.psi.LatteVariableElement"
                        methods=[getName setName getNameIdentifier getVariableName]
                    }

argsPhpMethod        ::= T_PHP_METHOD {
                        mixin="com.jantvrdik.intellij.latte.psi.impl.LattePhpMethodImpl"
                        implements="com.jantvrdik.intellij.latte.psi.LattePhpMethod"
                        methods=[getName setName getNameIdentifier getMethodName]
                    }

argsVarType        ::= T_MACRO_ARGS_VAR_TYPE (T_PHP_DOUBLE_COLON (phpMethod | T_PHP_CLASS | argsVar)?)? {
                        mixin="com.jantvrdik.intellij.latte.psi.impl.LatteVariableTypeElementImpl"
                        implements="com.jantvrdik.intellij.latte.psi.LatteVariableTypeElement"
                        methods=[getName setName getNameIdentifier getVariableType]
                    }

private
foreach        ::= T_WHITESPACE? phpArgs T_WHITESPACE? "as" T_WHITESPACE? (argsVar | arrayOfVariables) [ T_WHITESPACE? "=>" T_WHITESPACE? (argsVar | arrayOfVariables) ]

private
forCycle        ::= T_WHITESPACE? variableDefinition ";" T_WHITESPACE? argsVar phpOperators T_WHITESPACE? phpArgs T_WHITESPACE? ";" T_WHITESPACE? macroArg*

private
arrayOfVariables        ::= "[" argsVar ( T_WHITESPACE? "," T_WHITESPACE? argsVar )* "]"

private
variableDefinition        ::= argsVar T_WHITESPACE? "=" T_WHITESPACE? phpArgs

private
phpMethod       ::= argsPhpMethod (("()" | ("(" phpMethodArgs ")")) phpSubMethod*)? phpArgs?

phpMethodArgs       ::= (phpArgs ( T_WHITESPACE? "," T_WHITESPACE? phpArgs )*) {
                        mixin="com.jantvrdik.intellij.latte.psi.impl.LattePhpMethodArgsElementImpl"
                        implements="com.jantvrdik.intellij.latte.psi.LattePhpMethodArgsElement"
                    }

private
phpSubMethod      ::= (T_PHP_OBJECT_OPERATOR | T_PHP_DOUBLE_COLON) phpMethod?

// autoClosedBlock
autoClosedBlock  ::= &("{block" macroArgs? T_MACRO_MODIFIERS? "}") macroOpenTag structureToken*



// netteAttr
netteAttr        ::= T_HTML_TAG_NATTR_NAME T_WHITESPACE* (T_HTML_TAG_ATTR_EQUAL_SIGN netteAttrValue)? {
                        methods = [
                            attrName="T_HTML_TAG_NATTR_NAME"
                            attrValue="netteAttrValue"
                        ]
                     }

netteAttrValue   ::= T_HTML_TAG_ATTR_SQ ( forCycle | phpContent | macroContent? ) T_HTML_TAG_ATTR_SQ
                   | T_HTML_TAG_ATTR_DQ ( forCycle | phpContent | macroContent? ) T_HTML_TAG_ATTR_DQ
                   | ( forCycle | phpContent | macroContent? )

outerHtml ::= T_TEXT;

// tokens sets
private
structureToken   ::= outerHtml | macro | netteAttr


private
topLevelTokens   ::= T_MACRO_CLASSIC T_MACRO_CONTENT T_PHP_CONTENT T_MACRO_ANNOTATION topLevelTokens
